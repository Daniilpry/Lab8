# Lab8

# Завдання 8.1

## Мета

Дослідити поведінку системного виклику `write()` у ситуаціях, коли він може повернути кількість записаних байтів, **меншу за очікувану** (`nbytes`), **без виникнення помилки**.

---

## Умова

> Чи може виклик  
> `count = write(fd, buffer, nbytes);`  
> повернути значення, відмінне від `nbytes`?  
> Якщо так — чому? Навести робочий приклад програми.

---

## Коротка відповідь

Так, може. Це трапляється, коли:

- дескриптор відкритий у **неблокуючому режимі** (`O_NONBLOCK`),
- запис відбувається у **канал (pipe)**, **сокет** або **пристрій**, де не весь буфер можна записати одразу,
- системний буфер обмежений або частково заповнений.

---

## Демонстрація роботи
<img width="414" alt="image" src="https://github.com/user-attachments/assets/6fa8099e-5b4b-4ed6-99e5-2f5c76b43e68" />

---

# Завдання 8.2 – Робота з покажчиком файлу за допомогою `lseek()` та `read()`

## Мета

Показати, як системний виклик `lseek()` дозволяє перемістити покажчик поточної позиції у файлі, і як це впливає на результат читання (`read()`).

---

## Умова

> Є файл, що містить послідовність байтів:  
> `4, 5, 2, 2, 3, 3, 7, 9, 1, 5`
>
> У програмі виконуються виклики:
> ```c
> lseek(fd, 3, SEEK_SET);
> read(fd, &buffer, 4);
> ```
>
> Яке значення буде зчитано у буфер?

---

## Відповідь

- `lseek(fd, 3, SEEK_SET)` переміщує покажчик на **байт з індексом 3** — це другий байт зі значенням `2`.
- `read(..., 4)` зчитує наступні **4 байти**.
- Отже, буфер отримає:  
  **`2, 3, 3, 7`**

---

## Приклад реалізації

Програма:
1. Створює бінарний файл `data.bin` і записує у нього 10 байтів.
2. Відкриває файл для читання.
3. Зсуває покажчик на 3-й байт.
4. Читає 4 байти і виводить вміст буфера.

---

## Демонстрація роботи
<img width="206" alt="image" src="https://github.com/user-attachments/assets/2e5bd459-668a-4d5d-83df-40aff90ebca6" />

---

# Завдання 8.3 — Дослідження продуктивності `qsort()`

## Мета

- Дослідити поведінку бібліотечної функції `qsort()` на різних наборах даних.
- Виявити найгірші вхідні дані для цього алгоритму.
- Автоматизувати тестування та перевірку коректності.

---

## Що робить програма

1. Створює масиви розміром від 10 до 100000 елементів.
2. Наповнює їх наступними шаблонами:
   - Відсортовані (зростання),
   - Зворотні (спадання),
   - Однакові елементи,
   - Випадкові значення.
3. Вимірює час сортування `qsort()`.
4. Перевіряє правильність сортування.
5. Виводить результати у форматі таблиці.

---

## Демонстрація роботи
<img width="479" alt="image" src="https://github.com/user-attachments/assets/efb7bd86-3cc4-4266-91bd-81c5cd362c9a" />


