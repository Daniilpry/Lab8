# Lab8

# Завдання 8.1

## Мета

Дослідити поведінку системного виклику `write()` у ситуаціях, коли він може повернути кількість записаних байтів, **меншу за очікувану** (`nbytes`), **без виникнення помилки**.

---

## Умова

> Чи може виклик  
> `count = write(fd, buffer, nbytes);`  
> повернути значення, відмінне від `nbytes`?  
> Якщо так — чому? Навести робочий приклад програми.

---

## Коротка відповідь

Так, може. Це трапляється, коли:

- дескриптор відкритий у **неблокуючому режимі** (`O_NONBLOCK`),
- запис відбувається у **канал (pipe)**, **сокет** або **пристрій**, де не весь буфер можна записати одразу,
- системний буфер обмежений або частково заповнений.

---

## Демонстрація роботи
<img width="414" alt="image" src="https://github.com/user-attachments/assets/6fa8099e-5b4b-4ed6-99e5-2f5c76b43e68" />

---

# Завдання 8.2 – Робота з покажчиком файлу за допомогою `lseek()` та `read()`

## Мета

Показати, як системний виклик `lseek()` дозволяє перемістити покажчик поточної позиції у файлі, і як це впливає на результат читання (`read()`).

---

## Умова

> Є файл, що містить послідовність байтів:  
> `4, 5, 2, 2, 3, 3, 7, 9, 1, 5`
>
> У програмі виконуються виклики:
> ```c
> lseek(fd, 3, SEEK_SET);
> read(fd, &buffer, 4);
> ```
>
> Яке значення буде зчитано у буфер?

---

## Відповідь

- `lseek(fd, 3, SEEK_SET)` переміщує покажчик на **байт з індексом 3** — це другий байт зі значенням `2`.
- `read(..., 4)` зчитує наступні **4 байти**.
- Отже, буфер отримає:  
  **`2, 3, 3, 7`**

---

## Приклад реалізації

Програма:
1. Створює бінарний файл `data.bin` і записує у нього 10 байтів.
2. Відкриває файл для читання.
3. Зсуває покажчик на 3-й байт.
4. Читає 4 байти і виводить вміст буфера.

---

## Демонстрація роботи
<img width="206" alt="image" src="https://github.com/user-attachments/assets/2e5bd459-668a-4d5d-83df-40aff90ebca6" />

---

# Завдання 8.3 — Дослідження продуктивності `qsort()`

## Мета

- Дослідити поведінку бібліотечної функції `qsort()` на різних наборах даних.
- Виявити найгірші вхідні дані для цього алгоритму.
- Автоматизувати тестування та перевірку коректності.

---

## Що робить програма

1. Створює масиви розміром від 10 до 100000 елементів.
2. Наповнює їх наступними шаблонами:
   - Відсортовані (зростання),
   - Зворотні (спадання),
   - Однакові елементи,
   - Випадкові значення.
3. Вимірює час сортування `qsort()`.
4. Перевіряє правильність сортування.
5. Виводить результати у форматі таблиці.

---

## Демонстрація роботи
<img width="479" alt="image" src="https://github.com/user-attachments/assets/efb7bd86-3cc4-4266-91bd-81c5cd362c9a" />

---

# Завдання за варіантом `17`

## Мета

Продемонструвати, як **некоректне управління файловими дескрипторами** при роботі з `fork()` та `exec()` може призвести до **порушення логіки програми** — зокрема, до зависання процесу, який очікує завершення потоку.

---

## Опис проблеми

Програма створює канал зв'язку `pipe()` між двома процесами: батьківським і дочірнім.

- **Батьківський процес** не закриває дескриптор запису (`pipefd[1]`), хоча вже не планує писати в pipe.
- **Дочірній процес** виконує `exec()` зовнішньої програми (`cat`), яка читає з `stdin`.
- Оскільки `cat` чекає на кінець потоку (EOF), а дескриптор `pipefd[1]` ще відкритий у батьківському процесі, **EOF не надходить**, і програма зависає.

---

## Код програми з поясненням 

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

int main() {
    int pipefd[2];
    pipe(pipefd);

    pid_t pid = fork();

    if (pid == 0) {
        // Дочірній процес
        dup2(pipefd[0], STDIN_FILENO); // Підключення pipe до stdin
        close(pipefd[0]);
        // pipefd[1] не закрито! Це спричиняє зависання

        execlp("cat", "cat", NULL);
        perror("execlp");
        exit(1);
    } else {
        // Батьківський процес
        close(pipefd[0]); // Закриваємо кінець читання
        // pipefd[1] також не закрито, навіть якщо не використовується
        wait(NULL);
    }
    return 0;
}

